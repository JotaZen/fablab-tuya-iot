<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tuya Breaker - Monitor</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 12px;
        background: #f4f6f8;
        color: #222;
      }
      #events {
        border: 1px solid #ddd;
        padding: 8px;
        height: 60vh;
        overflow: auto;
        background: #fff;
      }
      .event {
        margin: 6px 0;
        padding: 6px;
        border-bottom: 1px solid #eee;
      }
      .meta {
        color: #666;
        font-size: 12px;
      }
      button {
        margin: 4px;
      }

      /* cards */
      .cards {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 12px;
      }
      .card {
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        padding: 12px;
      }
      .card .hdr {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .badge {
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 999px;
        color: #fff;
      }
      .badge.on {
        background: #28a745;
      }
      .badge.off {
        background: #6c757d;
      }
      .card pre {
        background: #f7f9fb;
        padding: 8px;
        border-radius: 6px;
        overflow: auto;
        font-size: 11px; /* JSON a√∫n m√°s peque√±o para tarjetas */
      }
      .muted {
        color: #666;
        font-size: 13px;
      }
      .small {
        font-size: 12px;
      }
      .btn {
        background: #007bff;
        color: #fff;
        border: none;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
      }
      .btn.secondary {
        background: #6c757d;
      }
      .btn.success {
        background: #28a745;
      }
      .btn.warning {
        background: #ffc107;
        color: #000;
      }
      .btn.danger {
        background: #dc3545;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* Tarjeta en carga */
      .charging-card {
        border: 2px solid #ffc107;
        box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
      }
      
      .tiny {
        font-size: 10px;
        font-style: italic;
      }
      .controls {
        margin-top: 8px;
      }
      #events pre,
      #tuyastatus {
        font-size: 12px;
      }
      .usage-card {
        background: #fff3cd;
        border-left: 3px solid #ffc107;
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
      }
      .timer-display {
        font-size: 18px;
        font-weight: bold;
        color: #ff6b6b;
        font-family: monospace;
      }
      .timer-active {
        background: #d4edda;
        border-left-color: #28a745;
      }
    </style>
  </head>
  <body>
    <h1>Tuya Breaker - Monitor</h1>
    <div style="display: flex; gap: 12px; align-items: flex-start">
      <div style="flex: 1">
        <h3>Arduinos</h3>
        <div id="arduinos"></div>
        <h3>Breakers</h3>
        <div id="breakers"></div>
      </div>
      <div
        style="width: 380px; display: flex; flex-direction: column; gap: 12px"
      >
        <div>
          <h3>Eventos (JSON)</h3>
          <div id="events"></div>
        </div>
        <div>
          <h3>Tuya Status (JSON formateado)</h3>
          <div
            id="tuyastatus"
            style="
              border: 1px solid #ddd;
              padding: 8px;
              height: 18vh;
              overflow: auto;
              background: #fff;
              white-space: pre-wrap;
            "
          ></div>
        </div>
        <div>
          <h3>Tarjetas</h3>
          <div id="tarjetas-controls"></div>
        </div>
      </div>
    </div>
    <script>
      let currentModels = { breakers: [], tarjetas: [], arduinos: [] };
      const ws = new WebSocket(
        (location.protocol === "https:" ? "wss://" : "ws://") +
          location.host +
          "/ws"
      );
      const events = document.getElementById("events");
      const tuyastatus = document.getElementById("tuyastatus");

      // logs full JSON objects (existing behavior)
      function logEvent(obj) {
        const el = document.createElement("div");
        el.className = "event";
        el.innerHTML =
          '<div class="meta">' +
          new Date().toLocaleTimeString() +
          "</div><pre>" +
          JSON.stringify(obj, null, 2) +
          "</pre>";
        events.prepend(el);
      }

      async function fetchModels() {
        const res = await fetch("/models");
        const data = await res.json();
        if (editingSaldoBid) {
          // si se est√° editando, no re-renderizar; solo actualizar modelo en memoria y saldos visibles
          currentModels = data;
          (data.tarjetas || []).forEach((t) => {
            document
              .querySelectorAll('[data-tid-saldo="' + t.id + '"]')
              .forEach((el) => {
                el.textContent =
                  t.saldo === undefined || t.saldo === null ? "‚Äî" : t.saldo;
              });
          });
        } else {
          renderModels(data);
        }
      }

      function fieldOrDash(v) {
        return v === null || v === undefined || v === "" ? "‚Äî" : v;
      }

      let editingSaldoBid = null;

      function renderModels(data) {
        currentModels = data;
        const a = document.getElementById("arduinos");
        const b = document.getElementById("breakers");
        a.innerHTML = "";
        b.innerHTML = "";

        const arduinosWrap = document.createElement("div");
        arduinosWrap.className = "cards";
        (data.arduinos || []).forEach((ad) => {
          const isCharge = !!ad.es_estacion_carga;
          const wps = ad.w_por_segundo !== undefined ? ad.w_por_segundo : "‚Äî";
          const lastHtml = ad.last
            ? '<div class="muted small">√öltimo:<pre style="font-size:12px">' +
              JSON.stringify(ad.last, null, 2) +
              "</pre></div>"
            : '<div class="muted small">Sin datos</div>';
          let chargingHtml = "";
          if (isCharge) {
            const sessions = Array.isArray(ad.charging) ? ad.charging : [];
            if (sessions.length > 0) {
              chargingHtml =
                '<div class="muted small">Cargando (' +
                sessions.length +
                "):</div>" +
                '<ul class="small" style="margin:4px 0 6px 16px; padding:0; list-style:disc">' +
                sessions
                  .map((s) => {
                    const id = (s.uid || "").toString();
                    const since = s.started_ms
                      ? new Date(s.started_ms).toLocaleTimeString()
                      : "‚Äî";
                    const w =
                      s.wps !== undefined && s.wps !== null ? s.wps : "‚Äî";
                    return (
                      "<li><strong>" +
                      id +
                      "</strong> desde " +
                      since +
                      " @ " +
                      w +
                      " W/s</li>"
                    );
                  })
                  .join("") +
                "</ul>";
            } else if (
              ad.last &&
              (ad.last.nfc || ad.last.uid || ad.last.rfid)
            ) {
              chargingHtml =
                '<div class="muted">Cargando NFC: <strong>' +
                (ad.last.nfc || ad.last.uid || ad.last.rfid) +
                "</strong></div>";
            }
          }
          const badge =
            '<span class="badge ' +
            (isCharge ? "on" : "off") +
            '">' +
            (isCharge ? "Estaci√≥n de carga" : "Lector") +
            "</span>";
          const body =
            '<div class="hdr"><div><strong>' +
            fieldOrDash(ad.id) +
            '</strong><div class="muted small">Arduino</div></div><div>' +
            badge +
            "</div></div>" +
            (isCharge
              ? '<div class="muted small">W/s: <strong>' +
                fieldOrDash(wps) +
                "</strong></div>"
              : "") +
            chargingHtml +
            "<div>" +
            lastHtml +
            "</div>";
          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = body;
          arduinosWrap.appendChild(card);
        });
        a.appendChild(arduinosWrap);

        const breakersWrap = document.createElement("div");
        breakersWrap.className = "cards";
        (data.breakers || []).forEach((br) => {
          const tarjeta = (data.tarjetas || []).find(
            (t) => t.id === br.tarjeta
          );
          const estado = br.estado ? "on" : "off";
          const saldo = fieldOrDash(
            br.saldo ?? (tarjeta ? tarjeta.saldo : "‚Äî")
          );
          const power = fieldOrDash(br.power);
          const energy = fieldOrDash(br.energy);
          const voltage = fieldOrDash(br.voltage);
          const current = fieldOrDash(br.current);
          const lastCons = fieldOrDash(br.consumption_last_ws);

          const hdr =
            '<div class="hdr"><div><strong>Breaker ' +
            (br.id.substring(0, 8) || "") +
            '</strong><div class="muted small">ID: ' +
            fieldOrDash(br.id) +
            "</div></div>" +
            '<div><span class="badge ' +
            (estado === "on" ? "on" : "off") +
            '">' +
            (estado === "on" ? "ON" : "OFF") +
            "</span></div></div>";

          // Generar bloque de uso/temporizador
          const usosProfe = br.usos_profe || 0;
          const usosIA = br.usos_ia || 0;
          const usandoProfeDesde = br.usando_profe_desde;
          const usandoIADesde = br.usando_ia_desde;
          
          let usageHtml = '';
          if (usandoProfeDesde || usandoIADesde || usosProfe > 0 || usosIA > 0) {
            const isActiveProfe = !!usandoProfeDesde;
            const isActiveIA = !!usandoIADesde;
            usageHtml = '<div class="usage-card ' + 
              (isActiveProfe || isActiveIA ? 'timer-active' : '') + 
              '" data-usage-card="' + br.id + '">' +
              '<div class="muted small"><strong>üìä Control de Uso</strong></div>' +
              '<div class="small">Profe: ' + usosProfe + ' usos' +
              (isActiveProfe ? ' <span class="timer-display" data-timer-profe="' + br.id + '">‚è±Ô∏è --:--</span>' : '') +
              '</div>' +
              '<div class="small">IA: ' + usosIA + ' usos' +
              (isActiveIA ? ' <span class="timer-display" data-timer-ia="' + br.id + '">‚è±Ô∏è --:--</span>' : '') +
              '</div>' +
              '<div style="margin-top:6px">' +
              '<button class="btn success small btn-start-timer" data-bid="' + br.id + '" data-type="profe" ' +
              (isActiveProfe ? 'disabled' : '') + '>‚ñ∂Ô∏è Iniciar Profe</button> ' +
              '<button class="btn warning small btn-start-timer" data-bid="' + br.id + '" data-type="ia" ' +
              (isActiveIA ? 'disabled' : '') + '>‚ñ∂Ô∏è Iniciar IA</button><br/>' +
              '<button class="btn danger small btn-stop-timer" data-bid="' + br.id + '" data-type="profe" ' +
              (!isActiveProfe ? 'disabled' : '') + '>‚èπÔ∏è Detener Profe</button> ' +
              '<button class="btn danger small btn-stop-timer" data-bid="' + br.id + '" data-type="ia" ' +
              (!isActiveIA ? 'disabled' : '') + '>‚èπÔ∏è Detener IA</button> ' +
              '<button class="btn secondary small btn-reset-usage" data-bid="' + br.id + '">üîÑ Reset</button>' +
              '</div></div>';
          }

          const body =
            hdr +
            '<div class="muted">' +
            br.nombre +
            "</div><br/>" +
            '<div class="muted">Potencia: <strong>' +
            power +
            " W</strong> &nbsp; Energ√≠a: <strong>" +
            energy +
            " kWh</strong><br/>" +
            "Consumo √∫ltimo 1s: <strong>" +
            lastCons +
            " W¬∑s</strong><br/>" +
            "Voltaje: <strong>" +
            voltage +
            " V</strong> &nbsp; Corriente: <strong>" +
            current +
            " A</strong>" +
            "</div>" +
            '<div style="margin-top:8px">' +
            (tarjeta
              ? '<div class="tarjeta-block" style="border-left:3px solid #007bff;padding-left:8px;border-radius:4px;background:#f8fbff;">' +
                '<div class="muted small">Tarjeta asociada: <strong>' +
                fieldOrDash(tarjeta.id) +
                "</strong></div>" +
                '<div class="muted small">Saldo tarjeta: <strong class="tarjeta-saldo" data-tid-saldo="' +
                tarjeta.id +
                '">' +
                fieldOrDash(tarjeta.saldo) +
                "</strong></div>" +
                '<div class="muted small" style="margin-top:6px">Saldo del breaker: <span class="breaker-saldo" data-bid-saldo="' +
                br.id +
                '">' +
                (br.saldo === undefined || br.saldo === null ? "‚Äî" : br.saldo) +
                '</span> <button class="btn secondary btn-edit-saldo" data-bid="' +
                br.id +
                '">Editar</button></div>' +
                "</div>"
              : '<div class="muted">Sin tarjeta asignada</div>') +
            "</div>" +
            usageHtml +
            '<div class="controls">' +
            '<button data-id="' +
            br.id +
            '" class="btn">' +
            (br.estado ? "Apagar" : "Encender") +
            "</button>";

          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = body;
          breakersWrap.appendChild(card);
        });
        b.appendChild(breakersWrap);

        // agregar data-id a cada card para updates incrementales
        document.querySelectorAll("#breakers .card").forEach((card) => {
          const idMatch = card.innerHTML.match(/ID: ([^<]+)/);
          if (idMatch) {
            card.dataset.bid = idMatch[1];
          }
        });

        // wire only toggle buttons (those with data-id) to avoid interfering with edit/save buttons
        document.querySelectorAll("button[data-id]").forEach((btn) => {
          btn.onclick = async (ev) => {
            const id = btn.getAttribute("data-id");
            if (!id) return;
            const res = await fetch(
              "/breakers/" + encodeURIComponent(id) + "/toggle",
              { method: "POST" }
            ).then((r) => r.json());
            logEvent(res);
            fetchModels();
          };
        });

        // wire refresh buttons
        document.querySelectorAll("button[data-refresh-id]").forEach((btn) => {
          btn.onclick = async (ev) => {
            const id = btn.getAttribute("data-refresh-id");
            if (!id) return;
            btn.disabled = true;
            btn.textContent = "‚è≥ Actualizando...";
            try {
              const res = await fetch(
                "/breakers/" + encodeURIComponent(id) + "/refresh",
                { method: "POST" }
              ).then((r) => r.json());
              logEvent(res);
              if (res.ok) {
                logEvent({
                  type: "info",
                  msg: `Breaker ${id.substring(
                    0,
                    8
                  )} actualizado: ${JSON.stringify(res.updated)}`,
                });
              }
              // fetchModels se ejecutar√° autom√°ticamente por el broadcast
            } catch (e) {
              logEvent({ type: "error", msg: `Error refresh: ${e.message}` });
            } finally {
              btn.disabled = false;
              btn.textContent = "üîÑ Refresh";
            }
          };
        });

        // Controles para tarjetas: lista read-only en la barra lateral
        const tarjetasDiv = document.getElementById("tarjetas-controls");
        if (tarjetasDiv) {
          tarjetasDiv.innerHTML = "";
          (data.tarjetas || []).forEach((t) => {
            // Calcular carga actual si est√° en alguna estaci√≥n
            let cargaActual = 0;
            let cargaAcumulada = t.carga_acumulada || 0;
            let arduinoId = null;
            (data.arduinos || []).forEach((arduino) => {
              if (!arduino.es_estacion_carga) return;
              const charging = arduino.charging || [];
              charging.forEach((sess) => {
                if (sess.uid === t.id) {
                  const wps = sess.wps || 0;
                  const startedMs = sess.started_ms || Date.now();
                  const elapsedS = (Date.now() - startedMs) / 1000;
                  cargaActual = wps * elapsedS;
                  arduinoId = arduino.id;
                }
              });
            });

            // Calcular progreso de carga
            const maxCarga = usageLimits?.max_carga_por_tarjeta || 2000;
            const cargaTotalPendiente = cargaAcumulada + cargaActual;
            const cargaLimitada = Math.min(cargaTotalPendiente, maxCarga);
            const porcentajeCarga = (cargaLimitada / maxCarga) * 100;

            const el = document.createElement("div");
            el.className = "card" + (cargaActual > 0 ? " charging-card" : "");
            el.innerHTML =
              '<div class="hdr"><div><strong>Tarjeta ' +
              (t.id || "") +
              '</strong><div class="muted small">ID tarjeta</div></div></div>' +
              '<div class="muted">Saldo: <strong>' +
              (t.saldo === undefined || t.saldo === null ? "‚Äî" : t.saldo.toFixed(2)) +
              " W¬∑s</strong></div>" +
              (cargaActual > 0
                ? '<div style="background:#fff3cd;padding:6px;border-radius:4px;margin-top:6px;">' +
                  '<div class="muted small">‚ö° Cargando en <strong>' +
                  arduinoId +
                  "</strong></div>" +
                  '<div class="muted small">Carga actual: <strong class="carga-actual-' +
                  t.id +
                  '">' +
                  cargaActual.toFixed(2) +
                  " W¬∑s</strong></div>" +
                  '<div style="margin-top:6px;">' +
                  '<div style="display:flex;justify-content:space-between;font-size:0.65rem;margin-bottom:3px;">' +
                  '<span>Progreso</span>' +
                  '<span style="font-weight:700;color:' + (porcentajeCarga >= 90 ? '#dc3545' : porcentajeCarga >= 70 ? '#ffc107' : '#28a745') + ';">' +
                  porcentajeCarga.toFixed(1) + '%</span>' +
                  '</div>' +
                  '<div style="background:#ddd;height:8px;border-radius:4px;overflow:hidden;">' +
                  '<div class="carga-progress-index-' + t.id + '" style="height:100%;width:' + porcentajeCarga + '%;' +
                  'background:' + (porcentajeCarga >= 90 ? '#dc3545' : porcentajeCarga >= 70 ? '#ffc107' : '#28a745') + ';' +
                  'transition:width 0.3s ease;"></div>' +
                  '</div>' +
                  '<div style="font-size:0.6rem;color:#666;margin-top:2px;text-align:right;">' +
                  '<span class="carga-total-index-' + t.id + '">' + cargaLimitada.toFixed(2) + '</span> / ' + maxCarga.toFixed(0) + ' W¬∑s' +
                  '</div>' +
                  '</div>' +
                  "</div>"
                : "") +
              (t.carga_acumulada && t.carga_acumulada > 0
                ? '<div style="background:#d1ecf1;padding:6px;border-radius:4px;margin-top:6px;">' +
                  '<div class="muted small">Carga acumulada: <strong>' +
                  t.carga_acumulada.toFixed(2) +
                  " W¬∑s</strong></div>" +
                  '<div class="muted tiny">Se convertir√° a saldo en pr√≥ximo lector</div>' +
                  "</div>"
                : "");
            tarjetasDiv.appendChild(el);
          });
        }

        // Event delegation para manejar edici√≥n/guardado de saldo dentro de los breakers
        const breakersContainer = document.getElementById("breakers");
        breakersContainer.addEventListener("click", async (ev) => {
          const target = ev.target;
          if (target.matches(".btn-edit-saldo")) {
            const bid = target.getAttribute("data-bid");
            editingSaldoBid = bid;
            // mostrar input inline
            const displaySpan = document.querySelector(
              '[data-bid-saldo="' + bid + '"]'
            );
            if (!displaySpan) return;
            const current = displaySpan.textContent.trim();
            const editHtml =
              '<input type="text" class="input-saldo-edit" data-bid-input="' +
              bid +
              '" value="' +
              (current === "‚Äî" ? "" : current) +
              '" style="width:100px"/> <button class="btn btn-save-saldo" data-bid-save="' +
              bid +
              '">Guardar</button> <button class="btn secondary btn-cancel-saldo" data-bid-cancel="' +
              bid +
              '">Cancelar</button>';
            displaySpan.style.display = "none";
            target.style.display = "none";
            // insertar contenedor de edici√≥n
            let editCont = document.querySelector(".edit-saldo-" + bid);
            if (!editCont) {
              editCont = document.createElement("span");
              editCont.className = "edit-saldo-" + bid;
              target.parentNode.appendChild(editCont);
            }
            editCont.innerHTML = editHtml;
          } else if (target.matches(".btn-save-saldo")) {
            const bid = target.getAttribute("data-bid-save");
            const input = document.querySelector(
              '.input-saldo-edit[data-bid-input="' + bid + '"]'
            );
            if (!input) return;
            const val = input.value;
            const br = (currentModels.breakers || []).find((x) => x.id === bid);
            if (!br || !br.tarjeta) {
              logEvent({ ok: false, error: "breaker sin tarjeta asociada" });
              return;
            }
            const tid = br.tarjeta;
            const res = await fetch(
              "/tarjetas/" + encodeURIComponent(tid) + "/saldo",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ saldo: val }),
              }
            ).then((r) => r.json());
            logEvent(res);
            // limpiar UI (volver a mostrar span) y refrescar modelos
            const displaySpan = document.querySelector(
              '[data-bid-saldo="' + bid + '"]'
            );
            const editCont = document.querySelector(".edit-saldo-" + bid);
            const editBtn = document.querySelector(
              '.btn-edit-saldo[data-bid="' + bid + '"]'
            );
            if (editCont) editCont.innerHTML = "";
            if (displaySpan) {
              displaySpan.style.display = "";
            }
            if (editBtn) {
              editBtn.style.display = "";
            }
            editingSaldoBid = null;
            fetchModels();
          } else if (target.matches(".btn-cancel-saldo")) {
            const bid = target.getAttribute("data-bid-cancel");
            const displaySpan = document.querySelector(
              '[data-bid-saldo="' + bid + '"]'
            );
            const editCont = document.querySelector(".edit-saldo-" + bid);
            const editBtn = document.querySelector(
              '.btn-edit-saldo[data-bid="' + bid + '"]'
            );
            if (editCont) editCont.innerHTML = "";
            if (displaySpan) {
              displaySpan.style.display = "";
            }
            if (editBtn) {
              editBtn.style.display = "";
            }
            editingSaldoBid = null;
          } else if (target.matches(".btn-start-timer")) {
            // Iniciar temporizador
            const bid = target.getAttribute("data-bid");
            const type = target.getAttribute("data-type"); // 'profe' o 'ia'
            
            const res = await fetch(
              "/breakers/" + encodeURIComponent(bid) + "/usage",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  [`usando_${type}_desde`]: Date.now()
                }),
              }
            ).then((r) => r.json());
            
            logEvent(res);
            if (res.ok) {
              fetchModels();
            }
          } else if (target.matches(".btn-stop-timer")) {
            // Detener temporizador y consumir un uso
            const bid = target.getAttribute("data-bid");
            const type = target.getAttribute("data-type"); // 'profe' o 'ia'
            const br = (currentModels.breakers || []).find((x) => x.id === bid);
            
            if (br) {
              const currentUsos = br[`usos_${type}`] || 0;
              const res = await fetch(
                "/breakers/" + encodeURIComponent(bid) + "/usage",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    [`usos_${type}`]: currentUsos + 1,
                    [`usando_${type}_desde`]: null
                  }),
                }
              ).then((r) => r.json());
              
              logEvent(res);
              if (res.ok) {
                fetchModels();
              }
            }
          } else if (target.matches(".btn-reset-usage")) {
            // Resetear contadores de uso
            const bid = target.getAttribute("data-bid");
            
            if (confirm('¬øResetear todos los contadores de uso de este breaker?')) {
              const res = await fetch(
                "/breakers/" + encodeURIComponent(bid) + "/usage/reset",
                { method: "POST" }
              ).then((r) => r.json());
              
              logEvent(res);
              if (res.ok) {
                fetchModels();
              }
            }
          }
        });
      }

      function handleEvent(obj) {
        // si es update de breaker, refrescar modelos
        if (obj && obj.type === "breakers:update") {
          const br = currentModels.breakers.find((x) => x.id === obj.id);
          if (br) {
            br.estado = obj.state === "on";
            updateBreakerCard(br.id);
          } else {
            fetchModels();
          }
        }
        if (obj && obj.type === "breakers:consumption") {
          const br = currentModels.breakers.find((x) => x.id === obj.id);
          if (br) {
            if ("power" in obj) br.power = obj.power;
            if ("energy" in obj) br.energy = obj.energy;
            if ("voltage" in obj) br.voltage = obj.voltage;
            if ("current" in obj) br.current = obj.current;
            if ("ws" in obj) br.consumption_last_ws = obj.ws;
            updateBreakerCard(br.id);
          } else {
            fetchModels();
          }
        }
        // Handler para actualizaci√≥n de uso/temporizadores
        if (obj && obj.type === "breakers:usage_update") {
          const br = currentModels.breakers.find((x) => x.id === obj.id);
          if (br) {
            if ("usos_profe" in obj) br.usos_profe = obj.usos_profe;
            if ("usos_ia" in obj) br.usos_ia = obj.usos_ia;
            if ("usando_profe_desde" in obj) br.usando_profe_desde = obj.usando_profe_desde;
            if ("usando_ia_desde" in obj) br.usando_ia_desde = obj.usando_ia_desde;
            updateBreakerCard(br.id);
          } else {
            fetchModels();
          }
        }
        // actualizar tarjetas y arduinos a partir de broadcasts
        if (obj && obj.type === "tarjetas:update") {
          // actualizar modelo en memoria
          let t = currentModels.tarjetas.find((x) => x.id === obj.id);
          if (t) {
            Object.assign(t, obj.tarjeta);
          } else {
            (currentModels.tarjetas || []).push(obj.tarjeta);
          }
          // actualizar DOM in-place para evitar cerrar editores
          document
            .querySelectorAll('[data-tid-saldo="' + obj.id + '"]')
            .forEach((el) => {
              el.textContent =
                obj.tarjeta &&
                obj.tarjeta.saldo !== undefined &&
                obj.tarjeta.saldo !== null
                  ? obj.tarjeta.saldo
                  : "‚Äî";
            });
        }
        if (obj && obj.type === "arduinos:update") {
          const idx = (currentModels.arduinos || []).findIndex(
            (x) => x.id === obj.id
          );
          if (idx >= 0) {
            currentModels.arduinos[idx] =
              obj.arduino ||
              Object.assign({}, currentModels.arduinos[idx], obj);
          }
          fetchModels();
        }
        if (obj && obj.type === "models" && obj.data) {
          // si estamos editando saldo, no re-renderizar para no cerrar el input
          if (editingSaldoBid) {
            // solo actualizar el modelo en memoria
            currentModels = obj.data;
          } else {
            renderModels(obj.data);
          }
        }
      }

      function updateBreakerCard(id) {
        const container = document.getElementById("breakers");
        const card = Array.from(container.querySelectorAll(".card")).find(
          (c) => c.dataset.bid === id
        );
        if (!card) {
          return;
        }
        const br = currentModels.breakers.find((x) => x.id === id);
        if (!br) {
          return;
        }
        const tarjeta = (currentModels.tarjetas || []).find(
          (t) => t.id === br.tarjeta
        );
        const estado = br.estado ? "on" : "off";
        const saldo = br.saldo ?? (tarjeta ? tarjeta.saldo : "‚Äî") ?? "‚Äî";
        function fd(v) {
          return v === null || v === undefined || v === "" ? "‚Äî" : v;
        }
        const power = fd(br.power);
        const energy = fd(br.energy);
        const voltage = fd(br.voltage);
        const current = fd(br.current);
        const lastCons = fd(br.consumption_last_ws);
        card.querySelector(".badge").className =
          "badge " + (estado === "on" ? "on" : "off");
        card.querySelector(".badge").textContent =
          estado === "on" ? "ON" : "OFF";
        // Reemplazar bloque de m√©tricas (buscar por texto 'Saldo:')
        const metricsRegex = /Saldo:[\s\S]*?<\/div>/;
        card.innerHTML = card.innerHTML.replace(metricsRegex, () => {
          return (
            '<div class="muted">Saldo: <strong>' +
            saldo +
            "</strong><br/>" +
            "Potencia: <strong>" +
            power +
            " W</strong> &nbsp; Energ√≠a: <strong>" +
            energy +
            " kWh</strong><br/>" +
            "Consumo √∫ltimo 1s: <strong>" +
            lastCons +
            " W¬∑s</strong><br/>" +
            "Voltaje: <strong>" +
            voltage +
            " V</strong> &nbsp; Corriente: <strong>" +
            current +
            " A</strong>" +
            "</div>"
          );
        });
      }

      // Mostrar y mantener un historial corto de Tuya Status como JSON formateado
      const tuyaLog = [];
      function logTuya(obj) {
        try {
          tuyaLog.unshift(obj);
          if (tuyaLog.length > 50) tuyaLog.length = 50;
          tuyastatus.textContent = tuyaLog
            .map((x) => JSON.stringify(x, null, 2))
            .join("\n---\n");
        } catch (e) {
          tuyastatus.textContent = String(obj);
        }
      }

      // carga inicial y refresco peri√≥dico
      fetchModels();
      setInterval(fetchModels, 10000); // Aumentado a 10 segundos

      // Tick de consumo optimizado: una sola petici√≥n cada 2 segundos para todos los breakers
      let tickInProgress = false;
      setInterval(async () => {
        try {
          if (tickInProgress) {
            console.log("[Tick] Petici√≥n anterior a√∫n en curso, saltando...");
            return;
          }
          if (!currentModels || !Array.isArray(currentModels.breakers)) return;
          if (editingSaldoBid) return; // no operar durante edici√≥n manual

          const elapsed = 2.0; // 2 segundos - reducido de 1s
          tickInProgress = true;

          // Llamada √∫nica al servidor para procesar todos los breakers
          const res = await fetch("/breakers/tick-consumption", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ elapsed: elapsed }),
          }).then((r) => r.json());

          // Actualizar UI con los resultados
          if (res && res.ok && Array.isArray(res.breakers)) {
            // Actualizar consumption_last_ws de cada breaker procesado
            res.breakers.forEach((item) => {
              const br = currentModels.breakers.find(
                (x) => x.id === item.breaker_id
              );
              if (br) {
                br.consumption_last_ws = item.ws;
                updateBreakerCard(br.id);
              }
            });

            // El servidor ya envi√≥ broadcast de tarjetas:update via WebSocket,
            // pero podemos refrescar modelos para asegurar sincronizaci√≥n
            // (el broadcast llegar√° async y actualizar√° la UI autom√°ticamente)
          }

          if (res && res.errors && res.errors.length > 0) {
            console.error("Errores en tick de consumo:", res.errors);
          }
        } catch (e) {
          console.error("Error en tick de consumo:", e);
        } finally {
          tickInProgress = false;
        }
      }, 2000); // Aumentado a 2 segundos
      
      // Actualizar temporizadores cada segundo
      function updateTimers() {
        const now = Date.now();
        
        // Actualizar temporizadores de uso de breakers
        currentModels.breakers.forEach((br) => {
          if (br.usando_profe_desde) {
            const timerEl = document.querySelector('[data-timer-profe="' + br.id + '"]');
            if (timerEl) {
              const elapsed = Math.floor((now - br.usando_profe_desde) / 1000);
              const mins = Math.floor(elapsed / 60);
              const secs = elapsed % 60;
              timerEl.textContent = `‚è±Ô∏è ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
          }
          if (br.usando_ia_desde) {
            const timerEl = document.querySelector('[data-timer-ia="' + br.id + '"]');
            if (timerEl) {
              const elapsed = Math.floor((now - br.usando_ia_desde) / 1000);
              const mins = Math.floor(elapsed / 60);
              const secs = elapsed % 60;
              timerEl.textContent = `‚è±Ô∏è ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
          }
        });
        
        // Actualizar carga actual de tarjetas en tiempo real
        const maxCarga = usageLimits?.max_carga_por_tarjeta || 2000;
        currentModels.tarjetas.forEach((t) => {
          const arduinos = currentModels.arduinos || [];
          let cargaActual = 0;
          let cargaAcumulada = t.carga_acumulada || 0;
          
          arduinos.forEach((arduino) => {
            if (!arduino.es_estacion_carga) return;
            const charging = arduino.charging || [];
            charging.forEach((sess) => {
              if (sess.uid === t.id) {
                const wps = sess.wps || 0;
                const startedMs = sess.started_ms || now;
                const elapsedS = (now - startedMs) / 1000;
                cargaActual = wps * elapsedS;
                
                // Actualizar texto de carga actual
                const cargaEl = document.querySelector('.carga-actual-' + t.id);
                if (cargaEl) {
                  cargaEl.textContent = cargaActual.toFixed(2) + ' W¬∑s';
                }
                
                // Actualizar barra de progreso
                const cargaTotalPendiente = cargaAcumulada + cargaActual;
                const cargaLimitada = Math.min(cargaTotalPendiente, maxCarga);
                const porcentajeCarga = (cargaLimitada / maxCarga) * 100;
                
                const progressBar = document.querySelector('.carga-progress-index-' + t.id);
                if (progressBar) {
                  progressBar.style.width = porcentajeCarga + '%';
                  
                  // Cambiar color seg√∫n porcentaje
                  let barColor = '#28a745';
                  if (porcentajeCarga >= 90) {
                    barColor = '#dc3545';
                  } else if (porcentajeCarga >= 70) {
                    barColor = '#ffc107';
                  }
                  progressBar.style.background = barColor;
                }
                
                // Actualizar texto de total
                const cargaTotalEl = document.querySelector('.carga-total-index-' + t.id);
                if (cargaTotalEl) {
                  cargaTotalEl.textContent = cargaLimitada.toFixed(2);
                }
              }
            });
          });
        });
      }
      
      setInterval(updateTimers, 1000); // Este se mantiene en 1s para los temporizadores visuales
      
      ws.onopen = () => {
        logEvent({ type: "info", msg: "conectado ws" });
        logTuya({ type: "info", msg: "ws conectado" });
      };
      ws.onmessage = (ev) => {
        try {
          const obj = JSON.parse(ev.data);
          handleEvent(obj);
          logEvent(obj);
          // always mirror a concise tuya-style line so "escucha todo"
          logTuya(obj);
        } catch (e) {
          logEvent({ raw: ev.data });
          logTuya(ev.data);
        }
      };
      ws.onclose = () => {
        logEvent({ type: "info", msg: "ws cerrado" });
        logTuya({ type: "info", msg: "ws cerrado" });
      };
    </script>
  </body>
</html>
