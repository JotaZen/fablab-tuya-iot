<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FabLab Energy Monitor - Display</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        color: #fff;
        overflow: hidden;
        padding: 15px;
        min-height: 100vh;
      }

      /* Partículas de fondo animadas - reducidas */
      .particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 0;
        pointer-events: none;
        opacity: 0.3;
      }

      .particle {
        position: absolute;
        background: rgba(100, 200, 255, 0.2);
        border-radius: 50%;
        animation: float linear infinite;
      }

      @keyframes float {
        0% {
          transform: translateY(100vh) rotate(0deg);
          opacity: 0;
        }
        10% {
          opacity: 0.3;
        }
        90% {
          opacity: 0.3;
        }
        100% {
          transform: translateY(-100px) rotate(360deg);
          opacity: 0;
        }
      }

      .container {
        position: relative;
        z-index: 1;
        max-width: 100%;
        margin: 0 auto;
        display: flex;
        gap: 12px;
        height: calc(100vh - 30px);
      }

      /* Sidebar con estadísticas verticales */
      .stats-sidebar {
        width: 180px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        flex-shrink: 0;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(0, 255, 136, 0.5);
        border-radius: 12px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 6px 24px rgba(0, 255, 136, 0.25);
      }

      .stat-label {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.8);
        text-transform: uppercase;
        letter-spacing: 1.5px;
        margin-bottom: 12px;
        font-weight: 600;
      }

      .stat-value {
        font-size: 2.2rem;
        font-weight: 700;
        color: #00ff88;
        text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        line-height: 1.2;
      }

      .stat-unit {
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.7);
        margin-left: 5px;
        font-weight: 500;
      }

      .breakers-grid {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 12px;
        overflow-y: auto;
        padding-right: 5px;
      }

      .breakers-grid::-webkit-scrollbar {
        width: 6px;
      }

      .breakers-grid::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }

      .breakers-grid::-webkit-scrollbar-thumb {
        background: rgba(0, 212, 255, 0.3);
        border-radius: 10px;
      }

      .breaker-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(0, 212, 255, 0.6);
        border-radius: 15px;
        padding: 15px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
      }

      /* Estado ON con brillo verde */
      .breaker-card.on {
        border-color: rgba(0, 255, 136, 0.7);
        background: rgba(0, 255, 136, 0.05);
      }

      .breaker-card.on::before {
        content: "";
        position: absolute;
        top: 10px;
        right: 10px;
        width: 15px;
        height: 15px;
        background: #00ff88;
        border-radius: 50%;
        box-shadow: 0 0 15px #00ff88, 0 0 30px #00ff88;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.3);
          opacity: 0.7;
        }
      }

      /* Alerta de energía baja */
      .breaker-card.low-balance {
        border-color: #ff9900;
        background: rgba(255, 153, 0, 0.1);
      }

      .breaker-card.low-balance::before {
        background: #ff9900;
        box-shadow: 0 0 15px #ff9900;
        animation: pulse 2s ease-in-out infinite;
      }

      /* Alerta crítica */
      .breaker-card.critical-balance {
        animation: criticalBlink 2s ease-in-out infinite;
      }

      @keyframes criticalBlink {
        0%, 100% {
          border-color: #ff3366;
          background: rgba(255, 51, 102, 0.1);
        }
        50% {
          border-color: #ff6699;
          background: rgba(255, 51, 102, 0.15);
        }
      }

      .breaker-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .breaker-name {
        font-size: 1.2rem;
        font-weight: 700;
        color: #00d4ff;
        text-shadow: 0 0 10px rgba(0, 212, 255, 0.6);
      }

      .breaker-status {
        font-size: 0.75rem;
        padding: 5px 12px;
        border-radius: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      .breaker-status.on {
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
        border: 1px solid #00ff88;
      }

      .breaker-status.off {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      .metric {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .metric-label {
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.85);
        text-transform: uppercase;
        letter-spacing: 0.8px;
        margin-bottom: 5px;
        font-weight: 600;
      }

      .metric-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: #fff;
      }

      .metric-value.power {
        color: #ffd700;
      }

      .metric-value.balance {
        color: #00ff88;
      }

      .metric-value.balance.low {
        color: #ff9900;
      }

      .metric-value.balance.critical {
        color: #ff3366;
      }

      .metric-unit {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.65);
        margin-left: 3px;
        font-weight: 500;
      }

      /* Métrica principal (energía disponible) */
      .metric-main {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 12px;
        padding: 12px;
        border: 2px solid rgba(0, 255, 136, 0.5);
        text-align: center;
        margin-top: 10px;
      }

      .metric-main .metric-label {
        font-size: 0.75rem;
        margin-bottom: 8px;
      }

      .metric-main .metric-value {
        font-size: 1.8rem;
        line-height: 1.2;
      }

      .metric-main .metric-unit {
        font-size: 1rem;
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #00d4ff);
        border-radius: 8px;
        transition: width 0.5s ease;
      }

      .progress-fill.low {
        background: linear-gradient(90deg, #ff9900, #ffaa33);
      }

      .progress-fill.critical {
        background: linear-gradient(90deg, #ff3366, #ff6699);
      }

      .timestamp {
        position: fixed;
        bottom: 10px;
        right: 15px;
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 300;
        z-index: 10;
      }

      /* Indicador de conexión */
      .connection-status {
        position: fixed;
        top: 10px;
        right: 15px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.7);
        z-index: 10;
      }

      .connection-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #00ff88;
        box-shadow: 0 0 8px #00ff88;
        animation: pulse 2s ease-in-out infinite;
      }

      .connection-dot.disconnected {
        background: #ff3366;
        box-shadow: 0 0 8px #ff3366;
      }

      /* Estilo para tarjetas en carga */
      .breaker-card.charging {
        border-color: rgba(255, 215, 0, 0.9) !important;
        background: rgba(255, 215, 0, 0.15) !important;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.5) !important;
        animation: chargingPulse 2s ease-in-out infinite;
      }

      @keyframes chargingPulse {
        0%, 100% {
          box-shadow: 0 0 25px rgba(255, 215, 0, 0.3), 0 6px 20px rgba(0, 0, 0, 0.5);
        }
        50% {
          box-shadow: 0 0 40px rgba(255, 215, 0, 0.6), 0 6px 20px rgba(0, 0, 0, 0.5);
        }
      }

      .charging-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(255, 215, 0, 0.2);
        border-radius: 10px;
        border: 1px solid rgba(255, 215, 0, 0.5);
      }

      .charging-header .tarjeta-name {
        font-size: 1.3rem;
        font-weight: 700;
        color: #ffd700;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      }

      .battery-icon {
        font-size: 1.8rem;
        animation: batteryCharge 1.5s ease-in-out infinite;
      }

      @keyframes batteryCharge {
        0%, 100% {
          opacity: 0.6;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
      }

      .charging-energy {
        text-align: center;
        padding: 15px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 12px;
        border: 2px solid rgba(255, 215, 0, 0.5);
      }

      .charging-energy .energy-label {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.85);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .charging-energy .energy-value {
        font-size: 2rem;
        font-weight: 700;
        color: #ffd700;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
      }

      .charging-energy .energy-unit {
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.7);
        margin-left: 5px;
      }

      /* Tarjetas de uso */
      .usage-cards {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .usage-card {
        flex: 1;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .usage-card.profe {
        border-color: rgba(100, 200, 255, 0.5);
      }

      .usage-card.ia {
        border-color: rgba(200, 100, 255, 0.5);
      }

      .usage-card-header {
        font-size: 0.65rem;
        color: rgba(255, 255, 255, 0.7);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .usage-card.profe .usage-card-header {
        color: #64c8ff;
      }

      .usage-card.ia .usage-card-header {
        color: #c864ff;
      }

      .usage-count {
        font-size: 1rem;
        font-weight: 700;
        color: #fff;
        margin-bottom: 3px;
      }

      .usage-count.editable-usage {
        transition: all 0.2s ease;
        padding: 4px 8px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid transparent;
      }

      .usage-count.editable-usage:hover {
        background: rgba(0, 212, 255, 0.2);
        border: 1px solid rgba(0, 212, 255, 0.5);
        transform: scale(1.05);
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
      }

      .usage-count.editable-usage:active {
        transform: scale(0.98);
      }

      .usage-timer {
        font-size: 1.1rem;
        font-weight: 700;
        font-family: "Courier New", monospace;
        letter-spacing: 1px;
      }

      .usage-timer.active {
        color: #00ff88;
        text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        animation: pulse 1s ease-in-out infinite;
      }

      .usage-timer.inactive {
        color: rgba(255, 255, 255, 0.3);
      }

      .usage-timer.warning {
        color: #ff9900;
        text-shadow: 0 0 10px rgba(255, 153, 0, 0.5);
      }

      .usage-timer.critical {
        color: #ff3366;
        text-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
        animation: criticalPulse 0.5s ease-in-out infinite;
      }

      @keyframes criticalPulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .usage-limit {
        font-size: 0.6rem;
        color: rgba(255, 255, 255, 0.5);
        margin-top: 2px;
      }

      /* Logo de la tarjeta */
      .card-logo {
        margin-top: 12px;
        text-align: center;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .card-logo img {
        max-width: 100%;
        height: auto;
        max-height: 80px;
        border-radius: 8px;
        opacity: 0.9;
        transition: opacity 0.3s ease;
      }

      .card-logo img:hover {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <!-- Partículas de fondo -->
    <div class="particles" id="particles"></div>

    <!-- Indicador de conexión -->
    <div class="connection-status">
      <div class="connection-dot" id="connectionDot"></div>
      <span id="connectionText">Conectado</span>
    </div>

    <div class="container">
      <!-- Sidebar con estadísticas verticales -->
      <div class="stats-sidebar">
        <div class="stat-card">
          <div class="stat-value">
            <span id="activeBreakers">0</span><span class="stat-unit">/<span id="totalBreakers">0</span></span>
          </div>
        </div>
      </div>

      <!-- Grid de breakers -->
      <div class="breakers-grid" id="breakersGrid"></div>
    </div>

    <!-- Timestamp -->
    <div class="timestamp" id="timestamp">Cargando...</div>

    <script>
      // Generar partículas de fondo
      const particlesContainer = document.getElementById("particles");
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement("div");
        particle.className = "particle";
        const size = Math.random() * 3 + 1;
        particle.style.width = size + "px";
        particle.style.height = size + "px";
        particle.style.left = Math.random() * 100 + "%";
        particle.style.animationDuration = Math.random() * 20 + 15 + "s";
        particle.style.animationDelay = Math.random() * 10 + "s";
        particlesContainer.appendChild(particle);
      }

      // WebSocket connection
      const ws = new WebSocket(
        (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws"
      );

      let currentModels = { breakers: [], tarjetas: [], arduinos: [] };
      let isConnected = false;
      let usageLimits = {
        tiempo_profe_segundos: 1800,
        tiempo_ia_segundos: 900,
        max_usos_profe: 5,
        max_usos_ia: 3
      };

      ws.onopen = () => {
        isConnected = true;
        updateConnectionStatus(true);
        console.log("WebSocket conectado");
      };

      ws.onclose = () => {
        isConnected = false;
        updateConnectionStatus(false);
        console.log("WebSocket desconectado");
        setTimeout(() => location.reload(), 3000);
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        updateConnectionStatus(false);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleWebSocketMessage(data);
        } catch (e) {
          console.error("Error parsing WebSocket message:", e);
        }
      };

      function handleWebSocketMessage(data) {
        if (data.type === "models" && data.data) {
          currentModels = data.data;
          renderDisplay();
        } else if (data.type === "breakers:update" || data.type === "breakers:consumption") {
          const breaker = currentModels.breakers.find((b) => b.id === data.id);
          if (breaker) {
            if (data.type === "breakers:update") {
              breaker.estado = data.state === "on";
            } else if (data.type === "breakers:consumption") {
              if ("power" in data) breaker.power = data.power;
              if ("voltage" in data) breaker.voltage = data.voltage;
              if ("current" in data) breaker.current = data.current;
              if ("energy" in data) breaker.energy = data.energy;
            }
            renderDisplay();
          }
        } else if (data.type === "tarjetas:update") {
          const tarjeta = currentModels.tarjetas.find((t) => t.id === data.id);
          if (tarjeta && data.tarjeta) {
            Object.assign(tarjeta, data.tarjeta);
            renderDisplay();
          }
        } else if (data.type === "breakers:usage_update") {
          const breaker = currentModels.breakers.find((b) => b.id === data.id);
          if (breaker) {
            if ("usos_profe" in data) breaker.usos_profe = data.usos_profe;
            if ("usos_ia" in data) breaker.usos_ia = data.usos_ia;
            if ("usando_profe_desde" in data) breaker.usando_profe_desde = data.usando_profe_desde;
            if ("usando_ia_desde" in data) breaker.usando_ia_desde = data.usando_ia_desde;
            renderDisplay();
          }
        } else if (data.type === "usage_limits:update") {
          usageLimits = data.limits;
          renderDisplay();
        }
      }

      function updateConnectionStatus(connected) {
        const dot = document.getElementById("connectionDot");
        const text = document.getElementById("connectionText");
        if (connected) {
          dot.classList.remove("disconnected");
          text.textContent = "Conectado";
        } else {
          dot.classList.add("disconnected");
          text.textContent = "Desconectado";
        }
      }

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      }

      function getTimeRemaining(startedMs, limitSeconds) {
        if (!startedMs) return null;
        const now = Date.now();
        const elapsedSeconds = Math.floor((now - startedMs) / 1000);
        const remaining = Math.max(0, limitSeconds - elapsedSeconds);
        return remaining;
      }

      function renderDisplay() {
        const breakers = currentModels.breakers || [];
        const tarjetas = currentModels.tarjetas || [];
        const arduinos = currentModels.arduinos || [];

        // Calcular breakers activos
        let activeCount = 0;

        breakers.forEach((b) => {
          if (b.estado) {
            activeCount++;
          }
        });

        // Actualizar estadísticas
        document.getElementById("activeBreakers").textContent = activeCount;
        document.getElementById("totalBreakers").textContent = breakers.length;

        // Renderizar breakers
        const grid = document.getElementById("breakersGrid");
        grid.innerHTML = "";

        breakers.forEach((breaker, index) => {
          const tarjeta = tarjetas.find((t) => t.id === breaker.tarjeta);
          const energia = tarjeta ? parseFloat(tarjeta.saldo || 0) : 0;
          const maxEnergia = 200000; // Límite máximo de energía
          const energiaPercent = Math.min((energia / maxEnergia) * 100, 100);

          // Verificar si la tarjeta está en carga
          let isCharging = false;
          if (tarjeta) {
            arduinos.forEach((arduino) => {
              if (arduino.charging && Array.isArray(arduino.charging)) {
                const charging = arduino.charging.find((c) => c.uid === tarjeta.id);
                if (charging) {
                  isCharging = true;
                }
              }
            });
          }

          // Determinar colores según porcentaje de energía
          let balanceClass = "";
          let cardClass = "breaker-card";

          if (isCharging) {
            cardClass += " charging";
          } else if (breaker.estado) {
            cardClass += " on";
            // Azul/Verde: > 50%, Amarillo: < 50%, Rojo: crítico (< 5%)
            if (energiaPercent === 0 || energia < 100) {
              balanceClass = "critical";
              cardClass += " critical-balance";
            } else if (energiaPercent < 50) {
              balanceClass = "low";
              cardClass += " low-balance";
            }
          } else {
            // OFF pero con alertas según energía
            if (energiaPercent === 0 || energia < 100) {
              balanceClass = "critical";
            } else if (energiaPercent < 50) {
              balanceClass = "low";
            }
          }

          let progressClass = "progress-fill";
          if (balanceClass === "critical") progressClass += " critical";
          else if (balanceClass === "low") progressClass += " low";

          const card = document.createElement("div");
          card.className = cardClass;

          // Asignar número secuencial (1-9) basado en el índice
          const logoNumber = index + 1;

          if (isCharging) {
            // Vista especial para tarjetas en carga
            // Calcular carga actual en tiempo real y sumarla al saldo
            let cargaActual = 0;
            let arduinoId = '';
            let wps = 0;
            let startedMs = Date.now();
            let sess = null;
            
            arduinos.forEach((arduino) => {
              if (arduino.charging && Array.isArray(arduino.charging)) {
                const charging = arduino.charging.find((c) => c.uid === tarjeta.id);
                if (charging) {
                  sess = charging;
                  wps = charging.wps || 0;
                  startedMs = charging.started_ms || Date.now();
                  const elapsedS = (Date.now() - startedMs) / 1000;
                  cargaActual = wps * elapsedS;
                  arduinoId = arduino.id;
                }
              }
            });
            
            // Calcular progreso basado en: (saldo actual + carga en tiempo real) / límite
            const maxCarga = usageLimits.max_carga_por_tarjeta || 2000;
            const saldoBase = energia; // energia = tarjeta.saldo (guardado en JSON)
            const saldoConCarga = saldoBase + cargaActual; // Saldo + carga en tiempo real
            const porcentajeCarga = (saldoConCarga / maxCarga) * 100;
            
            // Limitar visualmente al máximo
            const saldoMostrar = Math.min(saldoConCarga, maxCarga);
            
            // Determinar color de barra según porcentaje
            let barColor = 'linear-gradient(90deg, #00ff88, #00d4ff)';
            if (porcentajeCarga >= 90) {
              barColor = 'linear-gradient(90deg, #ff3366, #ff6699)';
            } else if (porcentajeCarga >= 70) {
              barColor = 'linear-gradient(90deg, #ff9900, #ffaa33)';
            }
            
            // Calcular tiempo transcurrido cargando
            const elapsedSeconds = Math.floor((Date.now() - startedMs) / 1000);
            const tiempoTranscurrido = formatTime(elapsedSeconds);
            
            card.innerHTML = `
              <div class="charging-header">
                <div class="battery-icon">🔋</div>
                <div class="tarjeta-name">${tarjeta?.nombre || "Tarjeta"}</div>
              </div>
              
              <div class="metric" style="margin-top: 15px; background: rgba(255, 215, 0, 0.15); border: 1px solid rgba(255, 215, 0, 0.4); padding: 15px;">
                <div class="metric-label" style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Estación</div>
                <div class="metric-value" style="color: #ffd700; font-size: 1.8rem; font-weight: 700;">
                  ${arduinoId}
                </div>
                <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.6); margin-top: 6px;">
                  Cargando a ${wps.toFixed(1)} W
                </div>
              </div>
              
              <div class="metric" style="margin-top: 15px; background: rgba(0, 0, 0, 0.3); padding: 15px;">
                <div class="metric-label" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <span style="font-size: 0.8rem;">Progreso</span>
                  <span style="font-weight: 700; font-size: 1.1rem; color: ${porcentajeCarga >= 90 ? '#ff3366' : porcentajeCarga >= 70 ? '#ff9900' : '#00ff88'};">
                    ${porcentajeCarga.toFixed(1)}%
                  </span>
                </div>
                <div class="progress-bar" style="margin-top: 8px; height: 16px;">
                  <div class="progress-fill carga-progress-${tarjeta.id}" 
                       style="width: ${Math.min(porcentajeCarga, 100)}%; background: ${barColor};">
                  </div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.75rem; color: rgba(255, 255, 255, 0.6);">
                  <span class="carga-total-display-${tarjeta.id}">${Math.round(saldoMostrar).toLocaleString()} W</span>
                  <span>Máximo: ${maxCarga.toFixed(0)} W</span>
                </div>
              </div>
              
              <div style="flex: 1;"></div>
              
              <div class="card-logo"><img src="/static/logos/${logoNumber}.jpg" alt="Logo ${logoNumber}" onerror="this.style.display='none'"></div>
            `;
          } else {
            // Vista normal para breakers
            const usosProfe = breaker.usos_profe || 0;
            const usosIa = breaker.usos_ia || 0;
            const usandoProfeDesde = breaker.usando_profe_desde;
            const usandoIaDesde = breaker.usando_ia_desde;

            // Calcular tiempos restantes
            const tiempoProfeRestante = getTimeRemaining(usandoProfeDesde, usageLimits.tiempo_profe_segundos);
            const tiempoIaRestante = getTimeRemaining(usandoIaDesde, usageLimits.tiempo_ia_segundos);

            // Determinar clases de tiempo
            let timerProfeClass = 'inactive';
            let timerIaClass = 'inactive';
            
            if (tiempoProfeRestante !== null) {
              if (tiempoProfeRestante <= 60) timerProfeClass = 'critical';
              else if (tiempoProfeRestante <= 300) timerProfeClass = 'warning';
              else timerProfeClass = 'active';
            }
            
            if (tiempoIaRestante !== null) {
              if (tiempoIaRestante <= 30) timerIaClass = 'critical';
              else if (tiempoIaRestante <= 120) timerIaClass = 'warning';
              else timerIaClass = 'active';
            }

            card.innerHTML = `
              <div class="breaker-header">
                <div class="breaker-name">${breaker.nombre || "Breaker"}</div>
                <div class="breaker-status ${breaker.estado ? "on" : "off"}">
                  ${breaker.estado ? "● ON" : "○ OFF"}
                </div>
              </div>

              <div class="metric-main">
                <div class="metric-label">Energía Disponible</div>
                <div class="metric-value balance ${balanceClass}">
                  ${Math.round(energia).toLocaleString()}<span class="metric-unit">W</span>
                </div>
                <div class="progress-bar" style="margin-top: 10px;">
                  <div class="${progressClass}" style="width: ${energiaPercent}%"></div>
                </div>
              </div>

              <div class="usage-cards">
                <div class="usage-card profe">
                  <div class="usage-card-header">👨‍🏫 Profe</div>
                  <div class="usage-count editable-usage" 
                       data-breaker="${breaker.id}" 
                       data-type="profe" 
                       data-current="${usosProfe}"
                       style="cursor: pointer; user-select: none;"
                       title="Click para editar">
                    ${usosProfe}/${usageLimits.max_usos_profe} usos
                  </div>
                  <div class="usage-timer ${timerProfeClass}" data-type="profe" data-breaker="${breaker.id}">
                    ${tiempoProfeRestante !== null ? formatTime(tiempoProfeRestante) : '--:--'}
                  </div>
                  <div class="usage-limit">${Math.floor(usageLimits.tiempo_profe_segundos/60)}min límite</div>
                </div>
                <div class="usage-card ia">
                  <div class="usage-card-header">🤖 IA</div>
                  <div class="usage-count editable-usage" 
                       data-breaker="${breaker.id}" 
                       data-type="ia" 
                       data-current="${usosIa}"
                       style="cursor: pointer; user-select: none;"
                       title="Click para editar">
                    ${usosIa}/${usageLimits.max_usos_ia} usos
                  </div>
                  <div class="usage-timer ${timerIaClass}" data-type="ia" data-breaker="${breaker.id}">
                    ${tiempoIaRestante !== null ? formatTime(tiempoIaRestante) : '--:--'}
                  </div>
                  <div class="usage-limit">${Math.floor(usageLimits.tiempo_ia_segundos/60)}min límite</div>
                </div>
              </div>

              <div style="flex: 1;"></div>

              <div class="card-logo"><img src="/static/logos/${logoNumber}.jpg" alt="Logo ${logoNumber}" onerror="this.style.display='none'"></div>
            `;
          }

          grid.appendChild(card);
        });

        updateTimestamp();
      }

      function updateTimestamp() {
        const now = new Date();
        const formatted = now.toLocaleString("es-ES", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
        document.getElementById("timestamp").textContent = `Última actualización: ${formatted}`;
      }

      // Fetch inicial - SOLO UNA VEZ al cargar
      async function fetchInitialData() {
        try {
          const response = await fetch("/models");
          const data = await response.json();
          currentModels = data;
          
          // Cargar límites
          const limitsResponse = await fetch("/usage-limits");
          const limitsData = await limitsResponse.json();
          if (limitsData.ok && limitsData.limits) {
            usageLimits = limitsData.limits;
          }
          
          renderDisplay();
        } catch (e) {
          console.error("Error fetching initial data:", e);
        }
      }

      // Actualizar temporizadores cada segundo sin re-renderizar todo
      function updateTimers() {
        // Actualizar temporizadores de uso
        document.querySelectorAll('.usage-timer').forEach(timer => {
          const type = timer.dataset.type;
          const breakerId = timer.dataset.breaker;
          const breaker = currentModels.breakers.find(b => b.id === breakerId);
          
          if (!breaker) return;
          
          const usandoDesde = type === 'profe' ? breaker.usando_profe_desde : breaker.usando_ia_desde;
          const limitSeconds = type === 'profe' ? usageLimits.tiempo_profe_segundos : usageLimits.tiempo_ia_segundos;
          
          const remaining = getTimeRemaining(usandoDesde, limitSeconds);
          
          if (remaining !== null) {
            timer.textContent = formatTime(remaining);
            
            // Actualizar clases
            timer.classList.remove('active', 'warning', 'critical', 'inactive');
            if (type === 'profe') {
              if (remaining <= 60) timer.classList.add('critical');
              else if (remaining <= 300) timer.classList.add('warning');
              else timer.classList.add('active');
            } else {
              if (remaining <= 30) timer.classList.add('critical');
              else if (remaining <= 120) timer.classList.add('warning');
              else timer.classList.add('active');
            }
          } else {
            timer.textContent = '--:--';
            timer.classList.remove('active', 'warning', 'critical');
            timer.classList.add('inactive');
          }
        });
        
        // Actualizar carga actual en tiempo real
        const tarjetas = currentModels.tarjetas || [];
        const arduinos = currentModels.arduinos || [];
        const now = Date.now();
        const maxCarga = usageLimits.max_carga_por_tarjeta || 2000;
        
        tarjetas.forEach((tarjeta) => {
          let cargaActual = 0;
          
          arduinos.forEach((arduino) => {
            if (!arduino.es_estacion_carga) return;
            const charging = arduino.charging || [];
            const sess = charging.find((c) => c.uid === tarjeta.id);
            if (sess) {
              const wps = sess.wps || 0;
              const startedMs = sess.started_ms || now;
              const elapsedS = (now - startedMs) / 1000;
              cargaActual = wps * elapsedS;
              
              // Actualizar barra de progreso basado en: (saldo + carga en tiempo real) / límite
              const saldoBase = tarjeta.saldo || 0;
              const saldoConCarga = saldoBase + cargaActual;
              const saldoMostrar = Math.min(saldoConCarga, maxCarga);
              const porcentajeCarga = (saldoConCarga / maxCarga) * 100;
              
              // Actualizar ancho de barra
              const progressBar = document.querySelector('.carga-progress-' + tarjeta.id);
              if (progressBar) {
                progressBar.style.width = Math.min(porcentajeCarga, 100) + '%';
                
                // Cambiar color según porcentaje
                let barColor = 'linear-gradient(90deg, #00ff88, #00d4ff)';
                if (porcentajeCarga >= 90) {
                  barColor = 'linear-gradient(90deg, #ff3366, #ff6699)';
                } else if (porcentajeCarga >= 70) {
                  barColor = 'linear-gradient(90deg, #ff9900, #ffaa33)';
                }
                progressBar.style.background = barColor;
              }
              
              // Actualizar texto mostrando saldo + carga en tiempo real
              const cargaTotalEl = document.querySelector('.carga-total-display-' + tarjeta.id);
              if (cargaTotalEl) {
                cargaTotalEl.innerHTML = `${Math.round(saldoMostrar).toLocaleString()} W`;
              }
            }
          });
        });
      }

      // ✅ FETCH INICIAL SOLO UNA VEZ - WebSocket maneja el resto
      fetchInitialData();
      
      // Manejador de eventos para editar contadores de uso
      document.addEventListener('click', async (e) => {
        const target = e.target.closest('.editable-usage');
        if (!target) return;
        
        const breakerId = target.dataset.breaker;
        const type = target.dataset.type; // 'profe' o 'ia'
        const currentValue = parseInt(target.dataset.current) || 0;
        const maxValue = type === 'profe' ? usageLimits.max_usos_profe : usageLimits.max_usos_ia;
        
        const newValue = prompt(
          `Editar usos de ${type.toUpperCase()}\n` +
          `Valor actual: ${currentValue}/${maxValue}\n` +
          `Límite máximo: ${maxValue}\n\n` +
          `Ingrese nuevo valor:`,
          currentValue
        );
        
        if (newValue === null) return; // Cancelado
        
        const numValue = parseInt(newValue);
        if (isNaN(numValue) || numValue < 0) {
          alert('Por favor ingrese un número válido (0 o mayor)');
          return;
        }
        
        // Actualizar en el servidor
        try {
          const field = type === 'profe' ? 'usos_profe' : 'usos_ia';
          const response = await fetch(`/breakers/${breakerId}/usage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ [field]: numValue })
          });
          
          const result = await response.json();
          if (result.ok) {
            // Actualizar modelo local
            const breaker = currentModels.breakers.find(b => b.id === breakerId);
            if (breaker) {
              breaker[field] = numValue;
              renderDisplay();
            }
          } else {
            alert('Error al actualizar: ' + (result.error || 'desconocido'));
          }
        } catch (err) {
          console.error('Error actualizando uso:', err);
          alert('Error de conexión al actualizar');
        }
      });
      
      // ✅ Solo actualizar UI local cada segundo (sin HTTP)
      setInterval(updateTimestamp, 1000);
      setInterval(updateTimers, 1000);

      // ❌ TICK AUTOMÁTICO DESHABILITADO - El index.html ya lo hace
      // No hacer tick desde display para evitar duplicados
    </script>
  </body>
</html>
